/// <reference types="node" />
import { BigNumber, BigNumberish } from "@ethersproject/bignumber";
import { Provider, TransactionRequest, BlockTag } from "@ethersproject/abstract-provider";
import { BaseProvider } from "@ethersproject/providers";
import { BytesLike } from "@ethersproject/bytes";
import { Contract } from "@ethersproject/contracts";
import { Deferrable } from "@ethersproject/properties";
declare type CallRequest = {
    target: string;
    callData: BytesLike;
};
declare type BatchableOverrides = {
    blockTag?: BlockTag;
};
interface Multicall extends Contract {
    readonly callStatic: {
        aggregate(calls: CallRequest[], overrides?: BatchableOverrides): Promise<{
            blockNumber: BigNumber;
            returnData: string[];
        }>;
    };
    readonly functions: {
        getEthBalance(addr: string, overrides?: BatchableOverrides): Promise<[BigNumber]>;
    };
}
interface BatchedCalls extends BatchableOverrides {
    calls: CallRequest[];
    callbacks: [(resolveValue: string) => void, (rejectReason: any) => void][];
}
export interface BatchedProvider extends BaseProvider {
    batchingDelayMs: number;
    chainId: number;
}
export declare const isBatchedProvider: (provider: Provider) => provider is BatchedProvider;
export declare const Batched: <T extends new (...args: any[]) => BaseProvider>(Base: T) => {
    new (...args: any[]): {
        batchingDelayMs: number;
        _chainId: number;
        _multicall?: Multicall | undefined;
        _timeoutId: any;
        _batched: BatchedCalls;
        _numberOfBatchedCalls: number;
        _numberOfActualCalls: number;
        _timeOfLastRatioCheck?: number | undefined;
        chainId: number;
        _dispatchCalls(): Promise<void>;
        _enqueueCall(call: CallRequest): Promise<string>;
        _alreadyBatchedCallsConflictWith(blockTag?: string | number | undefined): boolean;
        call(request: Deferrable<TransactionRequest>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<BigNumber>;
        _networkPromise: Promise<import("@ethersproject/providers").Network>;
        _network: import("@ethersproject/providers").Network;
        _events: import("@ethersproject/providers/lib/base-provider").Event[];
        formatter: import("@ethersproject/providers").Formatter;
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: NodeJS.Timer;
        _bootstrapPoll: NodeJS.Timer;
        _lastBlockNumber: number;
        _maxFilterBlockRange: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: Promise<number>;
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: Promise<{
            blockNumber: number;
            reqTime: number;
            respTime: number;
        }>;
        readonly anyNetwork: boolean;
        disableCcipRead: boolean;
        _ready(): Promise<import("@ethersproject/providers").Network>;
        readonly ready: Promise<import("@ethersproject/providers").Network>;
        ccipReadFetch(tx: import("@ethersproject/transactions").Transaction, calldata: string, urls: string[]): Promise<string | null>;
        _getInternalBlockNumber(maxAge: number): Promise<number>;
        poll(): Promise<void>;
        resetEventsBlock(blockNumber: number): void;
        readonly network: import("@ethersproject/providers").Network;
        detectNetwork(): Promise<import("@ethersproject/providers").Network>;
        getNetwork(): Promise<import("@ethersproject/providers").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber(): Promise<number>;
        _setFastBlockNumber(blockNumber: number): void;
        waitForTransaction(transactionHash: string, confirmations?: number | undefined, timeout?: number | undefined): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: {
            data: string;
            from: string;
            nonce: number;
            to: string;
            value: BigNumber;
            startBlock: number;
        }): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<BigNumber>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<number>;
        getCode(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: string | number | bigint | BigNumber | import("@ethersproject/bytes").Bytes | Promise<BigNumberish>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _wrapTransaction(tx: import("@ethersproject/transactions").Transaction, hash?: string | undefined, startBlock?: number | undefined): import("@ethersproject/abstract-provider").TransactionResponse;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/transactions").Transaction>;
        _getFilter(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string>;
        estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
        _getAddress(addressOrName: string | Promise<string>): Promise<string>;
        _getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>, includeTransactions?: boolean | undefined): Promise<import("@ethersproject/abstract-provider").Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").Block>;
        getBlockWithTransactions(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getTransaction(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        getTransactionReceipt(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getLogs(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice(): Promise<number>;
        _getBlockTag(blockTag: string | number | Promise<BlockTag>): Promise<BlockTag>;
        getResolver(name: string): Promise<import("@ethersproject/providers").Resolver | null>;
        _getResolver(name: string, operation?: string | undefined): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string | null>;
        lookupAddress(address: string | Promise<string>): Promise<string | null>;
        getAvatar(nameOrAddress: string): Promise<string | null>;
        perform(method: string, params: any): Promise<any>;
        _startEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _stopEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _addEventListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener, once: boolean): any;
        on(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        once(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        emit(eventName: import("@ethersproject/abstract-provider").EventType, ...args: any[]): boolean;
        listenerCount(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): number;
        listeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): import("@ethersproject/abstract-provider").Listener[];
        off(eventName: import("@ethersproject/abstract-provider").EventType, listener?: import("@ethersproject/abstract-provider").Listener | undefined): any;
        removeAllListeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): any;
        getFeeData(): Promise<import("@ethersproject/abstract-provider").FeeData>;
        addListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        removeListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        readonly _isProvider: boolean;
    };
} & T;
export declare const BatchedWebSocketAugmentedWeb3Provider: {
    new (...args: any[]): {
        batchingDelayMs: number;
        _chainId: number;
        _multicall?: Multicall | undefined;
        _timeoutId: any;
        _batched: BatchedCalls;
        _numberOfBatchedCalls: number;
        _numberOfActualCalls: number;
        _timeOfLastRatioCheck?: number | undefined;
        chainId: number;
        _dispatchCalls(): Promise<void>;
        _enqueueCall(call: CallRequest): Promise<string>;
        _alreadyBatchedCallsConflictWith(blockTag?: string | number | undefined): boolean;
        call(request: Deferrable<TransactionRequest>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<BigNumber>;
        _networkPromise: Promise<import("@ethersproject/providers").Network>;
        _network: import("@ethersproject/providers").Network;
        _events: import("@ethersproject/providers/lib/base-provider").Event[];
        formatter: import("@ethersproject/providers").Formatter;
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: NodeJS.Timer;
        _bootstrapPoll: NodeJS.Timer;
        _lastBlockNumber: number;
        _maxFilterBlockRange: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: Promise<number>;
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: Promise<{
            blockNumber: number;
            reqTime: number;
            respTime: number;
        }>;
        readonly anyNetwork: boolean;
        disableCcipRead: boolean;
        _ready(): Promise<import("@ethersproject/providers").Network>;
        readonly ready: Promise<import("@ethersproject/providers").Network>;
        ccipReadFetch(tx: import("@ethersproject/transactions").Transaction, calldata: string, urls: string[]): Promise<string | null>;
        _getInternalBlockNumber(maxAge: number): Promise<number>;
        poll(): Promise<void>;
        resetEventsBlock(blockNumber: number): void;
        readonly network: import("@ethersproject/providers").Network;
        detectNetwork(): Promise<import("@ethersproject/providers").Network>;
        getNetwork(): Promise<import("@ethersproject/providers").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber(): Promise<number>;
        _setFastBlockNumber(blockNumber: number): void;
        waitForTransaction(transactionHash: string, confirmations?: number | undefined, timeout?: number | undefined): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: {
            data: string;
            from: string;
            nonce: number;
            to: string;
            value: BigNumber;
            startBlock: number;
        }): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<BigNumber>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<number>;
        getCode(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: string | number | bigint | BigNumber | import("@ethersproject/bytes").Bytes | Promise<BigNumberish>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _wrapTransaction(tx: import("@ethersproject/transactions").Transaction, hash?: string | undefined, startBlock?: number | undefined): import("@ethersproject/abstract-provider").TransactionResponse;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/transactions").Transaction>;
        _getFilter(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string>;
        estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
        _getAddress(addressOrName: string | Promise<string>): Promise<string>;
        _getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>, includeTransactions?: boolean | undefined): Promise<import("@ethersproject/abstract-provider").Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").Block>;
        getBlockWithTransactions(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getTransaction(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        getTransactionReceipt(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getLogs(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice(): Promise<number>;
        _getBlockTag(blockTag: string | number | Promise<BlockTag>): Promise<BlockTag>;
        getResolver(name: string): Promise<import("@ethersproject/providers").Resolver | null>;
        _getResolver(name: string, operation?: string | undefined): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string | null>;
        lookupAddress(address: string | Promise<string>): Promise<string | null>;
        getAvatar(nameOrAddress: string): Promise<string | null>;
        perform(method: string, params: any): Promise<any>;
        _startEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _stopEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _addEventListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener, once: boolean): any;
        on(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        once(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        emit(eventName: import("@ethersproject/abstract-provider").EventType, ...args: any[]): boolean;
        listenerCount(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): number;
        listeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): import("@ethersproject/abstract-provider").Listener[];
        off(eventName: import("@ethersproject/abstract-provider").EventType, listener?: import("@ethersproject/abstract-provider").Listener | undefined): any;
        removeAllListeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): any;
        getFeeData(): Promise<import("@ethersproject/abstract-provider").FeeData>;
        addListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        removeListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        readonly _isProvider: boolean;
    };
} & {
    new (...args: any[]): {
        _wsProvider?: import("./WebSocketProvider").WebSocketProvider | undefined;
        _wsParams?: [string, import("@ethersproject/providers").Networkish] | undefined;
        _reconnectTimerId: any;
        _seenBlock: number;
        _blockListenerScheduled: boolean;
        readonly _blockListeners: Map<(_: never) => void, (blockNumber: number) => void>;
        readonly _blockListener: (blockNumber: number) => void;
        openWebSocket(url: string, network: import("@ethersproject/providers").Networkish): void;
        _onWebSocketClose(): void;
        closeWebSocket(): void;
        _switchover(): void;
        _onBlock(blockNumber: number): void;
        _retrySeenBlock<T>(perform: () => Promise<T>, startingBlock: number): Promise<T>;
        call(transaction: Deferrable<TransactionRequest>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<BigNumber>;
        _startBlockEvents(): void;
        _stopBlockEvents(): void;
        _wrap<T_1, U>(f: (t: T_1) => void, g: (f: (t: T_1) => void) => (u: U, { removeMe }: {
            isActive: () => boolean;
            removeMe: () => void;
        }) => void): [(t: T_1) => void, (u: U) => void];
        on(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        _addBlockListener(key: (_: never) => void, blockListener: (blockNumber: number) => void): any;
        once(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        off(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): any;
        _removeBlockListener(key: (_: never) => void): any;
        getTransaction(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        getTransactionReceipt(transactionHash: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<number>;
        getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").Block>;
        getBlockWithTransactions(blockHashOrBlockTag: string | number | Promise<BlockTag>): Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        _blockContainsTx(blockNumber: number, txHash: string): Promise<boolean>;
        _getTransactionReceiptFromLatest(txHash: string | Promise<string>, latestBlock?: number | undefined): Promise<import("@ethersproject/abstract-provider").TransactionReceipt | null>;
        waitForTransaction(txHash: string, confirmations?: number | undefined, timeout?: number | undefined): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        _networkPromise: Promise<import("@ethersproject/providers").Network>;
        _network: import("@ethersproject/providers").Network;
        _events: import("@ethersproject/providers/lib/base-provider").Event[];
        formatter: import("@ethersproject/providers").Formatter;
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: NodeJS.Timer;
        _bootstrapPoll: NodeJS.Timer;
        _lastBlockNumber: number;
        _maxFilterBlockRange: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: Promise<number>;
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: Promise<{
            blockNumber: number;
            reqTime: number;
            respTime: number;
        }>;
        readonly anyNetwork: boolean;
        disableCcipRead: boolean;
        _ready(): Promise<import("@ethersproject/providers").Network>;
        readonly ready: Promise<import("@ethersproject/providers").Network>;
        ccipReadFetch(tx: import("@ethersproject/transactions").Transaction, calldata: string, urls: string[]): Promise<string | null>;
        _getInternalBlockNumber(maxAge: number): Promise<number>;
        poll(): Promise<void>;
        resetEventsBlock(blockNumber: number): void;
        readonly network: import("@ethersproject/providers").Network;
        detectNetwork(): Promise<import("@ethersproject/providers").Network>;
        getNetwork(): Promise<import("@ethersproject/providers").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber(): Promise<number>;
        _setFastBlockNumber(blockNumber: number): void;
        _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: {
            data: string;
            from: string;
            nonce: number;
            to: string;
            value: BigNumber;
            startBlock: number;
        }): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<BigNumber>;
        getCode(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: string | number | bigint | BigNumber | import("@ethersproject/bytes").Bytes | Promise<BigNumberish>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _wrapTransaction(tx: import("@ethersproject/transactions").Transaction, hash?: string | undefined, startBlock?: number | undefined): import("@ethersproject/abstract-provider").TransactionResponse;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<import("@ethersproject/abstract-provider").TransactionResponse>;
        _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/transactions").Transaction>;
        _getFilter(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string>;
        estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
        _getAddress(addressOrName: string | Promise<string>): Promise<string>;
        _getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>, includeTransactions?: boolean | undefined): Promise<import("@ethersproject/abstract-provider").Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getLogs(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice(): Promise<number>;
        _getBlockTag(blockTag: string | number | Promise<BlockTag>): Promise<BlockTag>;
        getResolver(name: string): Promise<import("@ethersproject/providers").Resolver | null>;
        _getResolver(name: string, operation?: string | undefined): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string | null>;
        lookupAddress(address: string | Promise<string>): Promise<string | null>;
        getAvatar(nameOrAddress: string): Promise<string | null>;
        perform(method: string, params: any): Promise<any>;
        _startEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _stopEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _addEventListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener, once: boolean): any;
        emit(eventName: import("@ethersproject/abstract-provider").EventType, ...args: any[]): boolean;
        listenerCount(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): number;
        listeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): import("@ethersproject/abstract-provider").Listener[];
        removeAllListeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): any;
        getFeeData(): Promise<import("@ethersproject/abstract-provider").FeeData>;
        addListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        removeListener(eventName: import("@ethersproject/abstract-provider").EventType, listener: import("@ethersproject/abstract-provider").Listener): Provider;
        readonly _isProvider: boolean;
    };
} & typeof import("@ethersproject/providers").Web3Provider;
export {};
//# sourceMappingURL=BatchedProvider.d.ts.map