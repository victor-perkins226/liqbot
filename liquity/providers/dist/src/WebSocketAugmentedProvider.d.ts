/// <reference types="node" />
import { TransactionRequest, TransactionReceipt, TransactionResponse, BlockTag, EventType, Listener, Provider, Block } from "@ethersproject/abstract-provider";
import { BaseProvider, Web3Provider } from "@ethersproject/providers";
import { Networkish } from "@ethersproject/networks";
import { Deferrable } from "@ethersproject/properties";
import { WebSocketProvider } from "./WebSocketProvider";
export interface WebSocketAugmentedProvider extends BaseProvider {
    openWebSocket(url: string, network: Networkish): void;
    closeWebSocket(): void;
}
export declare const isWebSocketAugmentedProvider: (provider: Provider) => provider is WebSocketAugmentedProvider;
declare type BlockListenerContext = {
    isActive: () => boolean;
    removeMe: () => void;
};
export declare const WebSocketAugmented: <T extends new (...args: any[]) => BaseProvider>(Base: T) => {
    new (...args: any[]): {
        _wsProvider?: WebSocketProvider | undefined;
        _wsParams?: [string, Networkish] | undefined;
        _reconnectTimerId: any;
        _seenBlock: number;
        _blockListenerScheduled: boolean;
        readonly _blockListeners: Map<(_: never) => void, (blockNumber: number) => void>;
        readonly _blockListener: (blockNumber: number) => void;
        openWebSocket(url: string, network: Networkish): void;
        _onWebSocketClose(): void;
        closeWebSocket(): void;
        _switchover(): void;
        _onBlock(blockNumber: number): void;
        _retrySeenBlock<T_1>(perform: () => Promise<T_1>, startingBlock: number): Promise<T_1>;
        call(transaction: Deferrable<TransactionRequest>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<import("@ethersproject/bignumber").BigNumber>;
        _startBlockEvents(): void;
        _stopBlockEvents(): void;
        _wrap<T_3, U>(f: (t: T_3) => void, g: (f: (t: T_3) => void) => (u: U, { removeMe }: BlockListenerContext) => void): [(t: T_3) => void, (u: U) => void];
        on(eventName: EventType, listener: Listener): any;
        _addBlockListener(key: (_: never) => void, blockListener: (blockNumber: number) => void): any;
        once(eventName: EventType, listener: Listener): any;
        off(eventName: EventType, listener: Listener): any;
        _removeBlockListener(key: (_: never) => void): any;
        getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse>;
        getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<number>;
        getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
        getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        _blockContainsTx(blockNumber: number, txHash: string): Promise<boolean>;
        _getTransactionReceiptFromLatest(txHash: string | Promise<string>, latestBlock?: number | undefined): Promise<TransactionReceipt | null>;
        waitForTransaction(txHash: string, confirmations?: number | undefined, timeout?: number | undefined): Promise<TransactionReceipt>;
        _networkPromise: Promise<import("@ethersproject/providers").Network>;
        _network: import("@ethersproject/providers").Network;
        _events: import("@ethersproject/providers/lib/base-provider").Event[];
        formatter: import("@ethersproject/providers").Formatter;
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: NodeJS.Timer;
        _bootstrapPoll: NodeJS.Timer;
        _lastBlockNumber: number;
        _maxFilterBlockRange: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: Promise<number>;
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: Promise<{
            blockNumber: number;
            reqTime: number;
            respTime: number;
        }>;
        readonly anyNetwork: boolean;
        disableCcipRead: boolean;
        _ready(): Promise<import("@ethersproject/providers").Network>;
        readonly ready: Promise<import("@ethersproject/providers").Network>;
        ccipReadFetch(tx: import("@ethersproject/transactions").Transaction, calldata: string, urls: string[]): Promise<string | null>;
        _getInternalBlockNumber(maxAge: number): Promise<number>;
        poll(): Promise<void>;
        resetEventsBlock(blockNumber: number): void;
        readonly network: import("@ethersproject/providers").Network;
        detectNetwork(): Promise<import("@ethersproject/providers").Network>;
        getNetwork(): Promise<import("@ethersproject/providers").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber(): Promise<number>;
        _setFastBlockNumber(blockNumber: number): void;
        _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: {
            data: string;
            from: string;
            nonce: number;
            to: string;
            value: import("@ethersproject/bignumber").BigNumber;
            startBlock: number;
        }): Promise<TransactionReceipt>;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<import("@ethersproject/bignumber").BigNumber>;
        getCode(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: string | number | bigint | import("@ethersproject/bignumber").BigNumber | import("@ethersproject/bytes").Bytes | Promise<import("@ethersproject/bignumber").BigNumberish>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _wrapTransaction(tx: import("@ethersproject/transactions").Transaction, hash?: string | undefined, startBlock?: number | undefined): TransactionResponse;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
        _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/transactions").Transaction>;
        _getFilter(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string>;
        estimateGas(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/bignumber").BigNumber>;
        _getAddress(addressOrName: string | Promise<string>): Promise<string>;
        _getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>, includeTransactions?: boolean | undefined): Promise<Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getLogs(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice(): Promise<number>;
        _getBlockTag(blockTag: string | number | Promise<BlockTag>): Promise<BlockTag>;
        getResolver(name: string): Promise<import("@ethersproject/providers").Resolver | null>;
        _getResolver(name: string, operation?: string | undefined): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string | null>;
        lookupAddress(address: string | Promise<string>): Promise<string | null>;
        getAvatar(nameOrAddress: string): Promise<string | null>;
        perform(method: string, params: any): Promise<any>;
        _startEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _stopEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _addEventListener(eventName: EventType, listener: Listener, once: boolean): any;
        emit(eventName: EventType, ...args: any[]): boolean;
        listenerCount(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): number;
        listeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): Listener[];
        removeAllListeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): any;
        getFeeData(): Promise<import("@ethersproject/abstract-provider").FeeData>;
        addListener(eventName: EventType, listener: Listener): Provider;
        removeListener(eventName: EventType, listener: Listener): Provider;
        readonly _isProvider: boolean;
    };
} & T;
export declare const WebSocketAugmentedWeb3Provider: {
    new (...args: any[]): {
        _wsProvider?: WebSocketProvider | undefined;
        _wsParams?: [string, Networkish] | undefined;
        _reconnectTimerId: any;
        _seenBlock: number;
        _blockListenerScheduled: boolean;
        readonly _blockListeners: Map<(_: never) => void, (blockNumber: number) => void>;
        readonly _blockListener: (blockNumber: number) => void;
        openWebSocket(url: string, network: Networkish): void;
        _onWebSocketClose(): void;
        closeWebSocket(): void;
        _switchover(): void;
        _onBlock(blockNumber: number): void;
        _retrySeenBlock<T>(perform: () => Promise<T>, startingBlock: number): Promise<T>;
        call(transaction: Deferrable<TransactionRequest>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getBalance(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<import("@ethersproject/bignumber").BigNumber>;
        _startBlockEvents(): void;
        _stopBlockEvents(): void;
        _wrap<T_2, U>(f: (t: T_2) => void, g: (f: (t: T_2) => void) => (u: U, { removeMe }: BlockListenerContext) => void): [(t: T_2) => void, (u: U) => void];
        on(eventName: EventType, listener: Listener): any;
        _addBlockListener(key: (_: never) => void, blockListener: (blockNumber: number) => void): any;
        once(eventName: EventType, listener: Listener): any;
        off(eventName: EventType, listener: Listener): any;
        _removeBlockListener(key: (_: never) => void): any;
        getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse>;
        getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt>;
        getTransactionCount(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<number>;
        getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
        getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<import("@ethersproject/abstract-provider").BlockWithTransactions>;
        _blockContainsTx(blockNumber: number, txHash: string): Promise<boolean>;
        _getTransactionReceiptFromLatest(txHash: string | Promise<string>, latestBlock?: number | undefined): Promise<TransactionReceipt | null>;
        waitForTransaction(txHash: string, confirmations?: number | undefined, timeout?: number | undefined): Promise<TransactionReceipt>;
        _networkPromise: Promise<import("@ethersproject/providers").Network>;
        _network: import("@ethersproject/providers").Network;
        _events: import("@ethersproject/providers/lib/base-provider").Event[];
        formatter: import("@ethersproject/providers").Formatter;
        _emitted: {
            [eventName: string]: number | "pending";
        };
        _pollingInterval: number;
        _poller: NodeJS.Timer;
        _bootstrapPoll: NodeJS.Timer;
        _lastBlockNumber: number;
        _maxFilterBlockRange: number;
        _fastBlockNumber: number;
        _fastBlockNumberPromise: Promise<number>;
        _fastQueryDate: number;
        _maxInternalBlockNumber: number;
        _internalBlockNumber: Promise<{
            blockNumber: number;
            reqTime: number;
            respTime: number;
        }>;
        readonly anyNetwork: boolean;
        disableCcipRead: boolean;
        _ready(): Promise<import("@ethersproject/providers").Network>;
        readonly ready: Promise<import("@ethersproject/providers").Network>;
        ccipReadFetch(tx: import("@ethersproject/transactions").Transaction, calldata: string, urls: string[]): Promise<string | null>;
        _getInternalBlockNumber(maxAge: number): Promise<number>;
        poll(): Promise<void>;
        resetEventsBlock(blockNumber: number): void;
        readonly network: import("@ethersproject/providers").Network;
        detectNetwork(): Promise<import("@ethersproject/providers").Network>;
        getNetwork(): Promise<import("@ethersproject/providers").Network>;
        readonly blockNumber: number;
        polling: boolean;
        pollingInterval: number;
        _getFastBlockNumber(): Promise<number>;
        _setFastBlockNumber(blockNumber: number): void;
        _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: {
            data: string;
            from: string;
            nonce: number;
            to: string;
            value: import("@ethersproject/bignumber").BigNumber;
            startBlock: number;
        }): Promise<TransactionReceipt>;
        getBlockNumber(): Promise<number>;
        getGasPrice(): Promise<import("@ethersproject/bignumber").BigNumber>;
        getCode(addressOrName: string | Promise<string>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        getStorageAt(addressOrName: string | Promise<string>, position: string | number | bigint | import("@ethersproject/bignumber").BigNumber | import("@ethersproject/bytes").Bytes | Promise<import("@ethersproject/bignumber").BigNumberish>, blockTag?: string | number | Promise<BlockTag> | undefined): Promise<string>;
        _wrapTransaction(tx: import("@ethersproject/transactions").Transaction, hash?: string | undefined, startBlock?: number | undefined): TransactionResponse;
        sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
        _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/transactions").Transaction>;
        _getFilter(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>;
        _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string>;
        estimateGas(transaction: Deferrable<TransactionRequest>): Promise<import("@ethersproject/bignumber").BigNumber>;
        _getAddress(addressOrName: string | Promise<string>): Promise<string>;
        _getBlock(blockHashOrBlockTag: string | number | Promise<BlockTag>, includeTransactions?: boolean | undefined): Promise<Block | import("@ethersproject/abstract-provider").BlockWithTransactions>;
        getLogs(filter: import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash | Promise<import("@ethersproject/abstract-provider").Filter | import("@ethersproject/abstract-provider").FilterByBlockHash>): Promise<import("@ethersproject/abstract-provider").Log[]>;
        getEtherPrice(): Promise<number>;
        _getBlockTag(blockTag: string | number | Promise<BlockTag>): Promise<BlockTag>;
        getResolver(name: string): Promise<import("@ethersproject/providers").Resolver | null>;
        _getResolver(name: string, operation?: string | undefined): Promise<string>;
        resolveName(name: string | Promise<string>): Promise<string | null>;
        lookupAddress(address: string | Promise<string>): Promise<string | null>;
        getAvatar(nameOrAddress: string): Promise<string | null>;
        perform(method: string, params: any): Promise<any>;
        _startEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _stopEvent(event: import("@ethersproject/providers/lib/base-provider").Event): void;
        _addEventListener(eventName: EventType, listener: Listener, once: boolean): any;
        emit(eventName: EventType, ...args: any[]): boolean;
        listenerCount(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): number;
        listeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): Listener[];
        removeAllListeners(eventName?: string | import("@ethersproject/abstract-provider").EventFilter | (string | string[])[] | import("@ethersproject/abstract-provider").ForkEvent | undefined): any;
        getFeeData(): Promise<import("@ethersproject/abstract-provider").FeeData>;
        addListener(eventName: EventType, listener: Listener): Provider;
        removeListener(eventName: EventType, listener: Listener): Provider;
        readonly _isProvider: boolean;
    };
} & typeof Web3Provider;
export {};
//# sourceMappingURL=WebSocketAugmentedProvider.d.ts.map